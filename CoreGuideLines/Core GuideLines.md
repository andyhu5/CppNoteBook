# Core GuideLines



### R.13: 单个表达式语句中至多进行一次显式资源分配

##### 理由

如果在一条语句中进行两次显式资源分配的话就可能发生资源泄漏，这是因为许多的子表达式（包括函数参数）的求值顺序都是未指明的。

##### 示例

```
void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);
```

可以这样调用 `fun`：

```
// 不好：可能会泄漏
fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));
```

这是异常不安全的，因为编译器可能会把两个用以创建函数的两个参数的表达式重新排序。 特别是，编译器是可以交错执行这两个表达式的： 它可能会首先为两个对象都（通过调用 `operator new`）进行内存分配，然后再试图调用二者的 `Widget` 构造函数。 一旦其中一个构造函数调用抛出了异常，那么另一个对象的内存可能永远不会被释放了！

这个微妙的问题其实有一种简单的解决方案：永远不要在一条表达式语句中进行多于一次的显式资源分配。 例如：

```
shared_ptr<Widget> sp1(new Widget(a, b)); // 好多了，但不太干净
fun(sp1, new Widget(c, d));
```

最佳的方案是使用返回所有者对象的工厂函数，而完全避免显式的分配：

```
fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // 最佳
```

如果还没有，请自己编写一个工厂包装。



### I.23: 保持较少的函数参数数量



##### 理由

大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。

##### 讨论

两个最常见的使得函数具有过多参数的原因是：

1. *缺乏抽象* 缺少一种抽象，使得一个组合值被以 一组独立的元素的方式进行传递，而不是以一个单独的保证了不变式的对象来传递。 这不仅使其参数列表变长，而且会导致错误， 因为各个成分值无法再被某种获得保证的不变式进行保护。
2. *违反了“函数单一职责”原则* 这个函数试图完成多项任务，它可能应当被重构。
3. 

##### 注解

我们并不认为“性能”是一种不使用异常的合理理由。

- 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
- 通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。
- 一条对性能关键代码的好规则是，把检查从代码的[关键](https://lynnboy.github.io/CppCoreGuidelines-zh-CN/CppCoreGuidelines-zh-CN#Rper-critical)部分中移出去。
- 长期来看，更规整的代码会得到更好的优化。
- 在做出性能相关的声明前一定要小心地[进行测量](https://lynnboy.github.io/CppCoreGuidelines-zh-CN/CppCoreGuidelines-zh-CN#Rper-measure)。



P.4: 理想情况下，程序应当是静态类型安全的

##### 理由

理想情况下，程序应当完全是静态（编译期）类型安全的。 不幸的是，这是不可能的。有问题的领域：

- `union`
- 强制转换
- 数组退化
- 范围错误
- 窄化转换

##### 注解

这些领域是许多严重问题（如程序崩溃和安全性违规）的来源。 我们争取为它们给出替代技术。

##### 强制实施

如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。 我们总会给出替代方案。 例如：

- `union` - 使用 `variant`（C++17 提供）
- 强制转换 - 尽可能减少其使用；使用模板有助于这点
- 数组退化 - 使用 `span`（来自 GSL）
- 范围错误 - 使用 `span`
- 窄化转换 - 尽可能减少其使用，必须使用时则使用 `narrow` 或者 `narrow_cast`（来自 GSL



标准库和 GSL 都是这种理念的例子。 例如，我们并不使用混乱的数组，联合体，强制转换，麻烦的生存期问题，`gsl::owner`，等等， 它们用于实现一些关键抽象，诸如 `vector`，`span`，`lock_guard`，以及 `future`，我们使用的是 一般来说比我们有更多时间和专业能力的人所设计和实现的程序库。 类似地，我们也能够而且应该设计并实现更专门的程序库，而不是将其留给用户（通常是我们自己） 来面对需要重复把低级代码搞正确的挑战。 这是作为指导方针基石的[超集的子集原则](https://lynnboy.github.io/CppCoreGuidelines-zh-CN/CppCoreGuidelines-zh-CN#R0)的一种变体。



### P.13: 适当采用支持程序库

##### 理由

使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量； 如果你的大部分工时都必须耗费在实现上的话， 程序库的质量和文档很可能要比你能做到的要好得多。 程序库的成本（时间，工作量和资金等等）可以由大量的用户所分担。 一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。 对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间。 因此，如果你的应用领域中存在合适的程序库的话，请使用它。

##### 示例

```
std::sort(begin(v), end(v), std::greater<>());
```

如果你不是排序算法方面的专家而且有大量时间的话， 这样的代码比你为特定的应用所编写的任何代码都更可能正确并且运行得更快。 不使用标准库（或者你的应用所采用的基础程序库）是需要明确理由的，而不是反过来。

##### 注解

如果某个重要的领域中不存在设计良好，文档全面，并且有良好支持的程序库的话， 可能应当由你来设计并实现它，再进行使用了。



