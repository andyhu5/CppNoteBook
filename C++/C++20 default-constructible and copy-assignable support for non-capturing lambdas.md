# C++20 default-constructible and copy-assignable support for non-capturing lambdas

C++20 introduced a significant change to lambdas without capture. 

The autogenerated unique type is now **default-constructible and copy (and move) assignable.**

While the previous behaviour made sense for lambdas with captures and conceptually (each lambda is inherently an instance of its autogenerated type),

 it also made lambdas awkward to use as arguments to generic code.



```C++
#include <map>

int main() {
    // Using a function object
    struct Cmp {
        bool operator()(int l, int r) const {
            return l < r;
        }
    } cmp;

    std::map<int,int,Cmp> a; // OK
    std::map<int,int,decltype(cmp)> b; // OK
    a = b; // OK

    // Same logic using a lambda
    auto lcmp = [](int l, int r) { return l < r; };

    std::map<int,int,decltype(lcmp)> c(lcmp); // OK
    // pre-C++20 we have to copy-construct the comparator

    std::map<int,int,decltype(lcmp)> d; // Wouldn't compile pre-C++20
    // pre-C++20 delctype(lcmp) isn't default constructible

    c = d; // Wouldn't compile pre-C++20
    // pre-C++20 decltype(lcmp) isn't copy-assignable
}

```

我来详细解释这段 C++ 代码，它展示了 std::map 中比较器（Comparator）的使用，特别是 C++20 前后在构造和赋值行为上的差异。代码中使用了函数对象（Function Object）和 lambda 表达式作为比较器，并探讨了它们的类型特性。

------

代码结构

使用的头文件：

- <map>：提供 std::map，一个基于红黑树的关联容器，需要比较器来排序键。

主要内容：

- 使用函数对象 Cmp 定义比较器。
- 使用 lambda 表达式 lcmp 定义比较器。
- 对比 C++20 前后的行为。

------

1. 使用函数对象（Cmp）

代码

cpp

```cpp
struct Cmp {
    bool operator()(int l, int r) const {
        return l < r;
    }
} cmp;

std::map<int,int,Cmp> a;           // OK
std::map<int,int,decltype(cmp)> b; // OK
a = b;                             // OK
```

解释

- **Cmp 定义**：
  - Cmp 是一个函数对象（functor），重载了 operator()，比较两个 int 值，返回 l < r。
  - cmp 是 Cmp 的一个实例。
- **std::map<int,int,Cmp> a**：
  - 创建一个 std::map，键和值都是 int，使用类型 Cmp 作为比较器。
  - Cmp 是默认构造的（无参数），符合 std::map 的要求。
- **std::map<int,int,decltype(cmp)> b**：
  - 使用 decltype(cmp) 推导 cmp 的类型（即 Cmp），而不是直接指定类型。
  - b 也使用默认构造的比较器。
- **a = b**：
  - std::map 支持赋值操作，比较器类型相同（都是 Cmp），赋值成功。
- **特点**：
  - Cmp 是可默认构造、可拷贝、可赋值的类型，因此在 C++20 前后都有效。
  - 即使不显式传递 cmp，std::map 会使用默认构造的比较器实例。

------

2. 使用 Lambda 表达式（lcmp）

代码

cpp

```cpp
auto lcmp = [](int l, int r) { return l < r; };

std::map<int,int,decltype(lcmp)> c(lcmp); // OK
std::map<int,int,decltype(lcmp)> d;       // C++20 前失败
c = d;                                    // C++20 前失败
```

解释

- **lcmp 定义**：
  - lcmp 是一个无捕获的 lambda 表达式，比较两个 int，返回 l < r。
  - 每个 lambda 表达式有唯一的类型，由编译器生成（类似于匿名类）。
- **std::map<int,int,decltype(lcmp)> c(lcmp)**：
  - 使用 decltype(lcmp) 推导 lcmp 的类型。
  - 显式传递 lcmp 给 std::map 的构造函数，指定比较器实例。
  - 在 C++11 及之后都有效，因为 std::map 支持通过构造函数接收比较器对象。
- **std::map<int,int,decltype(lcmp)> d**：
  - **C++20 前**：
    - Lambda 类型（decltype(lcmp)）不可默认构造。
    - std::map 的默认构造函数要求比较器类型是默认构造的（DefaultConstructible），因此编译失败。
  - **C++20 后**：
    - C++20 放宽了 std::map 的要求，允许比较器类型不可默认构造，只要显式提供比较器实例即可。
    - 但这里未提供 lcmp，仍依赖默认构造，因此仍可能失败（除非编译器优化）。
- **c = d**：
  - **C++20 前**：
    - Lambda 类型（decltype(lcmp)）不可拷贝赋值（CopyAssignable），因为 lambda 默认不提供拷贝赋值操作。
    - std::map 的赋值操作要求比较器类型支持拷贝赋值，因此编译失败。
  - **C++20 后**：
    - C++20 通过 P0202R2 提案改进了容器行为，std::map 的赋值不再要求比较器可拷贝赋值。
    - 赋值时只拷贝键值对，比较器保持不变，c = d 成功。

------

C++20 前后的差异

C++20 前（C++11/14/17）

- **std::map 的要求**：
  - 比较器类型必须是 **默认构造的**（DefaultConstructible），因为默认构造函数会创建比较器实例。
  - 比较器类型必须是 **可拷贝赋值的**（CopyAssignable），因为赋值操作会复制比较器。
- **影响**：
  - Lambda 表达式不可默认构造（无默认构造函数）。
  - 无捕获的 lambda 可拷贝构造，但不可拷贝赋值。
  - 因此，std::map<int,int,decltype(lcmp)> d 和 c = d 会编译失败。

C++20 后

- **改进**（P0202R2 提案）：
  - 放宽了对比较器的要求：
    - 默认构造函数不再要求比较器默认构造，只需显式提供即可。
    - 赋值操作不再要求比较器可拷贝赋值，比较器保持不变。
- **影响**：
  - std::map<int,int,decltype(lcmp)> c(lcmp) 始终有效。
  - std::map<int,int,decltype(lcmp)> d 如果不提供 lcmp，仍可能失败（依赖实现）。
  - c = d 成功，因为赋值不再涉及比较器的拷贝。

------

输出和行为

- 这段代码没有显式输出，但可以通过编译器检查行为：
  - 在 C++17 下，注释中标记的行会导致编译错误。
  - 在 C++20 下，c = d 可以编译通过（假设 d 正确构造）。

------

完整示例（验证 C++20 行为）

cpp

```cpp
#include <map>
#include <print>

int main() {
    auto lcmp = [](int l, int r) { return l < r; };
    std::map<int, int, decltype(lcmp)> c(lcmp);
    std::map<int, int, decltype(lcmp)> d(lcmp); // C++20: 需要显式提供 lcmp
    c[1] = 10;
    d[2] = 20;
    c = d; // C++20: OK
    std::println("c[2] == {}", c[2]); // 输出: c[2] == 20
}
```

------

关键概念

1. **比较器（Comparator）**：
   - std::map 使用比较器维护键的顺序，默认是 std::less<Key>。
   - 自定义比较器（如 Cmp 或 lcmp）必须提供严格弱序（Strict Weak Ordering）。
2. **函数对象 vs Lambda**：
   - 函数对象（如 Cmp）是命名类型，可默认构造和赋值。
   - Lambda 是匿名类型，默认不可默认构造，C++20 前不可赋值。
3. **C++20 改进**：
   - 放宽容器对比较器构造和赋值的限制，提升了 lambda 的可用性。
4. **decltype**：
   - 用于推导变量或表达式的类型，保留引用属性。

------

总结

这段代码展示了 std::map 中比较器的使用方式，以及 C++20 前后在构造和赋值上的变化。C++20 通过放宽要求，使得 lambda 作为比较器更加灵活，但在默认构造时仍需显式提供实例。理解这些差异有助于编写兼容不同标准的代码。如果有具体问题或需要进一步澄清，请告诉我！