#  !!!C++17赋值变化

我来为你详细解释这段代码，逐步分析每个部分的作用和背后的 C++ 语义。这段代码涉及变量初始化、赋值表达式的行为，以及 C++17 前后的一些关键变化。

```C++
#include <string>
#include <iostream>

int main() {
    int v; // left uninitialized

    // Only well-defined since C++17
    int x = 1;
    (x = 2) = x; // x == 1
    // right side evalutes: 1 (prvalue)
    // left side evaluates: ref to x (x==2)
    // assignment evaluates: ref to x (x==1)
    std::cout << "x == " << x << "\n";

    std::string y = "a";
    (y = "b") = y; // y == "b"
    // right side evaluates: ref to y
    // left side evalutes: ref y (y=="b")
    // assignment evaluates: ref to y (y=="b")
    std::cout << "y == " << y << "\n";
}
```



------

1. 未初始化的全局变量

cpp

```cpp
int v; // left uninitialized
```

- **v 的定义**:
  - v 是一个全局变量（文件作用域），类型为 int。
  - 在 C++ 中，全局变量如果未显式初始化，会被自动初始化为零（0）。这是静态存储期的特性。
  - 因此，尽管注释说“未初始化”，但实际上 v 的值是 0，而不是未定义。
- **注意**:
  - 如果 v 是局部变量（例如在函数内定义），未初始化会导致未定义行为（UB），因为局部变量的初始值是未指定的。

------

2. 赋值表达式的行为（int 示例）

cpp

```cpp
int x = 1;
(x = 2) = x; // x == 2
```

解释

- **初始化**:

  - int x = 1; 将 x 初始化为 1。

- **表达式 (x = 2) = x**:

  - 在 C++ 中，赋值运算符 = 的返回值是一个 **左值引用（lvalue reference）**，引用的是赋值操作的左侧对象。
  - 因此，这个表达式可以分解如下：
    1. **(x = 2)**:
       - 将 2 赋给 x，此时 x 变为 2。
       - 表达式 (x = 2) 的结果是对 x 的左值引用，此时 x == 2。
    2. **(x = 2) = x**:
       - 将 x 的当前值（此时为 2）赋给 (x = 2) 的结果（即 x 的引用）。
       - 但注释指出最终 x == 1，这需要进一步分析。

- **C++17 前的行为**:

  - 在 C++17 之前，赋值表达式的求值顺序未完全定义。(x = 2) = x 的结果可能依赖于编译器的实现，可能导致未定义行为或意外结果。
  - 例如，右侧的 x 可能在 (x = 2) 之前被求值（仍为 1），导致最终 x 被赋值为 1。

- **C++17 后的行为**:

  - 从 C++17 开始，赋值表达式的求值顺序明确定义：左侧先求值，然后右侧求值，最后执行赋值。
  - 按此规则：
    1. (x = 2) 执行，x 变为 2，结果是对 x 的引用。
    2. 右侧的 x 求值为 2（因为 x 已被修改）。
    3. (x = 2) = x 将 2 赋给 x，x 保持为 2。
  - 但代码注释说 x == 1，这与 C++17 的规则不符，可能是笔误或特定编译器行为。

- **正确理解**:

  - 在 C++17 及之后的标准行为下，x 应为 2，而不是 1。
  - 如果你观察到 x == 1，可能是使用了旧编译器，或者注释有误。

- **逐步分解**:

  ```text
  x = 1;         // 初始状态
  (x = 2);       // x 变为 2，结果是 x 的引用
  (x = 2) = x;   // 将 x 的值（2）赋给 x，x 仍为 2
  ```

------

3. 赋值表达式的行为（std::string 示例）

cpp

```cpp
std::string y = "a";
(y = "b") = y; // y == "b"
```

解释

- **初始化**:

  - std::string y = "a"; 将 y 初始化为字符串 "a"。

- **表达式 (y = "b") = y**:

  - 与 int 示例类似，= 的返回值是对左侧对象的左值引用。
  - 分解如下：
    1. **(y = "b")**:
       - 将 "b" 赋给 y，此时 y 变为 "b"。
       - 表达式 (y = "b") 的结果是对 y 的左值引用，此时 y == "b"。
    2. **(y = "b") = y**:
       - 将 y 的当前值（"b"）赋给 (y = "b") 的结果（即 y 的引用）。
       - 最终 y 保持为 "b"。

- **C++17 后的行为**:

  - 按照 C++17 的求值顺序：
    1. (y = "b") 执行，y 变为 "b"，结果是对 y 的引用。
    2. 右侧的 y 求值为 "b"。
    3. (y = "b") = y 将 "b" 赋给 y，y 仍为 "b"。
  - 这与注释一致：y == "b"。

- **与 int 示例的区别**:

  - 在 int 示例中，右侧 x 是一个纯右值（prvalue），而这里 y 是 std::string 的左值引用，涉及对象的赋值操作。
  - std::string 的赋值运算符会正确处理字符串内容，确保结果一致。

- **逐步分解**:

  ```text
  y = "a";       // 初始状态
  (y = "b");     // y 变为 "b"，结果是 y 的引用
  (y = "b") = y; // 将 y 的值（"b"）赋给 y，y 仍为 "b"
  ```

------

代码注释的分析

int 示例的注释

cpp

```cpp
// right side evaluates: 1 (prvalue)
// left side evaluates: ref to x (x==2)
// assignment evaluates: ref to x (x==1)
```

- **问题**:
  - “right side evaluates: 1” 不符合 C++17 的求值顺序，因为右侧 x 应在 (x = 2) 之后求值，此时 x == 2。
  - “assignment evaluates: ref to x (x==1)” 与标准行为不符，可能是笔误或基于旧标准。
- **修正**:
  - 在 C++17 下，右侧应为 2，最终 x == 2。

std::string 示例的注释

cpp

```cpp
// right side evaluates: ref to y
// left side evaluates: ref y (y=="b")
// assignment evaluates: ref to y (y=="b")
```

- **正确性**:
  - 这与实际行为一致。
  - 右侧 y 是左值，值为 "b"。
  - 左侧 (y = "b") 是对 y 的引用，值为 "b"。
  - 最终赋值保持 y == "b"。

------

C++17 的关键变化

- **求值顺序**:
  - C++17 之前，(x = 2) = x 这样的表达式可能因求值顺序未定义而产生不同结果。
  - C++17 之后，明确规定赋值表达式的左侧先于右侧求值，保证了确定性。
- **为什么标注 "Only well-defined since C++17"**:
  - 在 C++17 之前，这种链式赋值的行为可能因编译器实现不同而异，属于未定义或未指定行为。
  - C++17 的规则澄清了这一点，使代码行为可预测。

------

总结

1. **int 示例**:
   - C++17 下，(x = 2) = x 应使 x == 2，注释中的 x == 1 可能是错误。
   - 展示了赋值表达式的左值引用特性。
2. **std::string 示例**:
   - (y = "b") = y 正确地将 y 保持为 "b"，与 C++17 行为一致。
   - 展示了对象赋值的稳定性。
3. **C++17 的影响**:
   - 保证了赋值表达式的求值顺序，使这类代码从未定义行为变为定义明确。

如果你观察到 x == 1 的结果，可能是使用了非 C++17 标准的编译器。建议使用现代编译器（支持 C++17 或更高）验证行为。如果还有疑问，欢迎继续讨论！