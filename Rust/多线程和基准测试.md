测试正确性：多线程代码 + loom。

测试性能：criterion 基准测试



1. 什么是 Criterion？

- 定义：criterion 是一个 Rust 库，用于编写和运行基准测试，测量代码的执行时间。它提供了统计分析（如平均时间、标准差、离群值检测）以确保结果的可靠性。
- 设计目标：
  - 高精度：通过多次运行和统计分析，减少噪声（如系统负载、垃圾回收）的影响。
  - 易用性：提供简单的 API，类似于 Rust 的内置测试框架。
  - 可视化：生成详细的报告和图表（如 HTML 报告、性能趋势图）。
- 适用场景：
  - 测量函数或代码片段的执行时间。
  - 比较不同实现的性能（如不同内存序的原子操作）。
  - 检测性能回归（如代码更改后性能下降）。

------

2. 主要功能

- 多次采样：重复运行基准测试，收集大量样本以计算统计数据（如平均值、中位数、标准差）。
- 离群值检测：自动识别和处理异常值（如缓存未命中、系统中断）。
- 统计分析：提供置信区间、噪声估计和性能变化检测。
- 可视化报告：生成 HTML 报告，包含运行时间分布图、性能趋势图等。
- 灵活配置：支持自定义采样次数、预热时间、测量时间等。
- 集成：与 Cargo 集成，易于在项目中使用。
- 跨平台：支持 Linux、macOS、Windows 等平台。

------

3. 安装和设置要使用 criterion，需要将其添加到你的项目依赖中，并配置基准测试环境。

1. 添加依赖： 编辑 Cargo.toml，添加 criterion 作为开发依赖：

   toml

   

   ```toml
   [dev-dependencies]
   criterion = { version = "0.5", features = ["html_reports"] }
   ```

   - version = "0.5" 是当前最新版本（截至 2025 年 9 月，可能需要检查最新版本）。
   - features = ["html_reports"] 启用 HTML 报告生成。

2. 创建基准测试目录：

   - 在项目根目录下创建 benches/ 目录（Cargo 默认识别此目录为基准测试目录）。
   - 创建一个基准测试文件，如 benches/my_bench.rs。

3. 编写基准测试： 以下是一个简单的 criterion 基准测试示例：

   rust

   

   ```rust
   use criterion::{criterion_group, criterion_main, Criterion};
   
   fn fibonacci(n: u64) -> u64 {
       if n <= 1 {
           n
       } else {
           fibonacci(n - 1) + fibonacci(n - 2)
       }
   }
   
   fn bench_fibonacci(c: &mut Criterion) {
       c.bench_function("fibonacci_20", |b| b.iter(|| fibonacci(20)));
   }
   
   criterion_group!(benches, bench_fibonacci);
   criterion_main!(benches);
   ```

4. 运行基准测试：

   bash

   

   ```bash
   cargo bench
   ```

   - 输出将显示 fibonacci_20 的平均执行时间、标准差等统计信息。
   - HTML 报告生成在 target/criterion/ 目录下。





------





loom 是一个专门为 Rust 设计的并发测试工具，用于分析和验证并发代码的正确性。它通过模拟所有可能的线程交错（interleavings）和内存操作顺序，帮助开发者发现并发程序中的潜在问题，如数据竞争、死锁或未定义行为。loom 特别适合测试使用原子操作（如 AtomicI32）或 thread::scope 的代码，例如你的上下文中的 AtomicI32::from_mut 和内存序测试。以下是对 loom 的详细介绍，包括其功能、使用方法、优势以及如何结合你的上下文（评估内存序或 thread::scope 代码）使用它。

------

1. 什么是 Loom？

- 定义：loom 是一个 Rust 库，用于测试并发代码的正确性。它通过模拟 Rust 并发原语（如 std::sync::atomic, std::thread）的行为，穷举所有可能的线程调度和内存序组合，检测潜在的并发错误。
- 设计目标：
  - 正确性验证：发现数据竞争、内存序错误或不安全的并发行为。
  - 模拟并发：在单线程环境中模拟多线程的各种交错，覆盖所有可能的执行路径。
  - 调试支持：提供详细的错误信息，帮助定位问题。
- 适用场景：
  - 测试原子操作（如 AtomicI32::store, AtomicI32::load）的内存序正确性。
  - 验证锁、信号量或自定义并发数据结构的线程安全性。
  - 调试复杂多线程代码（如使用 thread::scope 或 std::thread）。

------

2. 主要功能

- 线程交错模拟：模拟所有可能的线程调度顺序，覆盖并发程序的每一种执行路径。
- 内存序模拟：支持 Rust 的内存序（Ordering::Relaxed, Acquire, Release, SeqCst），检查不同内存序下的行为。
- 并发原语替换：loom 提供自己的 loom::sync::atomic, loom::thread 等模块，替换标准库的并发原语，以便在模拟环境中运行。
- 错误检测：捕获数据竞争、未定义行为、断言失败等。
- 调试输出：当发现错误时，提供详细的执行路径（trace）以帮助定位问题。
- 轻量级：在单线程环境中运行，避免实际多线程的非确定性。

------

3. 安装和设置要使用 loom，需要将其添加到项目依赖中，并使用 nightly Rust（因为 loom 依赖一些不稳定特性，且你的代码使用 atomic_from_mut 也需要 nightly）。

1. 添加依赖： 编辑 Cargo.toml，添加 loom 作为开发依赖：

   toml

   

   ```toml
   [dev-dependencies]
   loom = "0.7"  # 使用最新版本，截至 2025 年 9 月
   ```

2. 启用 Nightly Rust：

   - loom 要求 nightly 编译器，因为它使用不稳定特性（如自定义线程模拟）。

   - 设置 nightly 工具链：

     bash

     

     ```bash
     rustup override set nightly
     ```

     或运行测试时指定：

     bash

     

     ```bash
     cargo +nightly test
     ```

3. 创建测试文件：

   - 将测试放在 tests/ 目录（外部测试文件）或 #[cfg(test)] 模块中。
   - 使用 loom::model 运行并发测试。

------

4. 基本使用方法loom 的核心是 loom::model 函数，它在模拟环境中运行并发代码，穷举所有可能的线程交错。以下是一个简单的示例，测试 AtomicI32 的行为：

rust



```rust
#[cfg(test)]
mod tests {
    use loom::sync::atomic::{AtomicI32, Ordering};
    use loom::thread;

    #[test]
    fn test_atomic() {
        loom::model(|| {
            let value = AtomicI32::new(0);
            thread::spawn(|| {
                value.store(1, Ordering::Relaxed);
            });
            thread::spawn(|| {
                let v = value.load(Ordering::Relaxed);
                assert!(v == 0 || v == 1); // Relaxed 允许两种结果
            });
        });
    }
}
```

- 运行：

  bash

  

  ```bash
  cargo +nightly test
  ```

- 说明：

  - loom::model 模拟所有可能的线程交错。
  - loom::thread::spawn 替换 std::thread::spawn，在模拟环境中运行。
  - loom::sync::atomic::AtomicI32 替换标准库的 AtomicI32，支持内存序模拟。
  - 断言检查 value 是否为 0 或 1，因为 Relaxed 不保证同步。

------

5. 结合你的上下文：测试 AtomicI32::from_mut 和 thread::scope你的代码涉及 AtomicI32::from_mut 和 thread::scope，并且你关注内存序（如 Ordering::Relaxed vs. Ordering::SeqCst）的影响。以下是一个使用 loom 测试的示例，结合你的上下文：

rust



```rust
#![feature(atomic_from_mut)]

#[cfg(test)]
mod tests {
    use loom::sync::atomic::{AtomicI32, Ordering};
    use loom::thread;

    #[test]
    fn test_atomic_from_mut() {
        loom::model(|| {
            let mut value = 0;
            let atomic = AtomicI32::from_mut(&mut value);

            // 模拟 thread::scope 的线程
            let t1 = thread::spawn(|| {
                atomic.store(1, Ordering::Relaxed); // 测试 Relaxed
            });
            let t2 = thread::spawn(|| {
                let v = atomic.load(Ordering::Relaxed);
                assert!(v == 0 || v == 1); // Relaxed 允许两种结果
            });

            t1.join().unwrap(); // 模拟 scope 的自动 join
            t2.join().unwrap();
        });
    }

    #[test]
    fn test_atomic_seqcst() {
        loom::model(|| {
            let mut value = 0;
            let atomic = AtomicI32::from_mut(&mut value);

            let t1 = thread::spawn(|| {
                atomic.store(1, Ordering::SeqCst); // 测试 SeqCst
            });
            let t2 = thread::spawn(|| {
                let v = atomic.load(Ordering::SeqCst);
                // SeqCst 提供更强的顺序保证，可能仍看到 0 或 1
                assert!(v == 0 || v == 1);
            });

            t1.join().unwrap();
            t2.join().unwrap();
        });
    }
}
```

- 运行：

  bash

  

  ```bash
  cargo +nightly test
  ```

- 说明：

  - 使用 loom::model 模拟 thread::scope 的行为。
  - loom::thread::spawn 模拟线程，join 模拟 scope 的自动等待。
  - 测试 Relaxed 和 SeqCst 的行为，验证可能的 load 值。
  - Relaxed 允许 v == 0 或 v == 1（无严格顺序）。
  - SeqCst 提供更强的顺序保证，但在某些交错下仍可能看到 v == 0。

------

6. 优势和特点

- 穷尽测试：模拟所有可能的线程交错，覆盖难以通过实际运行发现的边界情况。
- 内存序验证：支持 Relaxed, Acquire, Release, SeqCst，检查内存序的正确性。
- 单线程模拟：在单线程中运行，避免实际多线程的非确定性，提高调试效率。
- 详细错误信息：当断言失败时，提供执行路径（trace），帮助定位问题。
- 轻量级：适合测试小型并发代码片段，如原子操作或锁实现。

------

7. 注意事项

- Nightly 要求：
  - loom 需要 nightly Rust（因为它使用不稳定特性，如自定义线程模拟）。
  - 你的代码使用 atomic_from_mut，也需要 nightly，确保兼容。
- 性能开销：
  - loom 穷举所有交错，可能导致测试运行时间较长，尤其是复杂并发代码。
  - 限制测试规模（如减少线程数或操作数）以降低开销。
- 局限性：
  - loom 模拟的是逻辑交错，无法测试实际硬件性能（如内存屏障的真实开销）。
  - 结合 criterion（如前所述）测量性能，结合 loom 验证正确性。
- 调试复杂性：
  - 如果测试失败，loom 会输出详细的执行路径，但可能需要仔细分析。
  - 使用 println! 或 loom::debug 添加调试信息。