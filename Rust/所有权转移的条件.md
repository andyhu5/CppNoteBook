在 Rust 中，第 3 行 let s3 = s1; 会导致所有权转移的原因，与 Rust 的所有权规则和 String 类型的特性有关。

以下是详细的解释：Rust 所有权规则Rust 的所有权系统有以下核心规则：

1. 每个值有且仅有一个所有者（owner）。
2. 当值的所有者超出作用域时，值会被自动释放（drop）。
3. 值的移动（move）会转移所有权，之后原变量无法再使用。
4. 借用（borrowing）允许临时访问值，但不能转移所有权。

代码分析我们逐行分析你的代码：

```rust
let s1 = String::from("hi"); // 创建一个 String 类型的 s1，拥有 "hi" 的所有权
let s2 = &s1;               // s1 被借用给了 s2 
let s3 = s1;               // 又将 s1 的所有权转移给 s3
println!("{}", s2);         // 试图使用 s2
```

1. 第 1 行：let s1 = String::from("hi");
   - 创建一个 String 类型的变量 s1，它拥有 "hi" 字符串的堆内存所有权。s1 是值的唯一所有者。
2. 第 2 行：let s2 = &s1;
   - 这里创建了一个对 s1 的不可变引用（immutable reference）s2。s2 是一个借用（borrow），它并不拥有 String 的数据，只是引用了 s1 所拥有的堆内存。
   - 根据 Rust 的借用规则，s1 仍然是所有者，但 s2 可以通过引用访问 s1 的内容。



1. 第 3 行：let s3 = s1;
   - 这一行尝试将 s1 赋值给 s3。在 Rust 中，对于像 String 这样存储在堆上的类型，赋值操作会触发所有权转移（move）：
     - s1 的所有权被转移到 s3，s3 成为 String 数据的新所有者。
     - s1 变得无效（unbound），后续无法再使用 s1。
   - 为什么是移动而不是复制？
     - String 类型存储在堆上，包含一个指向堆内存的指针、长度和容量。复制整个堆内存（深拷贝）代价较高，因此 Rust 默认执行移动（move），将指针、长度和容量转移给新变量，而不复制堆中的数据。
     - 只有实现了 Copy trait 的类型（比如 i32、f64 等基本类型）会在赋值时自动复制，而 String 未实现 Copy，因此会移动。