这是一个很好的观察！`rseq` 无法通过 `man 2 rseq` 查询到的原因如下：

## 主要原因

### 1. **系统调用太新**

- `rseq` 是在 **Linux 4.18** (2018年) 才引入的相对较新的系统调用
- 许多 Linux 发行版的 man-pages 包可能还没有包含这个新系统调用的文档

### 2. **man-pages 版本落后**

Ubuntu/Debian 等发行版为了稳定性，通常使用较旧版本的 man-pages 包，可能不包含最新的系统调用文档。

## 验证方法

### 检查你的 man-pages 版本：

```bash
dpkg -l | grep manpages
# 或者
man --version
```

### 检查系统支持的系统调用：

```bash
# 查看内核是否支持 rseq
grep -r rseq /proc/kallsyms
# 或者
ausyscall --dump | grep rseq
```

## 解决方案

### 1. **更新 man-pages**

```bash
sudo apt update
sudo apt install manpages-dev manpages-posix-dev
```

### 2. **在线查看文档**

可以访问：

- [Linux man pages online](https://man7.org/linux/man-pages/man2/rseq.2.html)
- [内核文档](https://www.kernel.org/doc/html/latest/userspace-api/rseq.html)

### 3. **查看内核源码文档**

```bash
# 如果安装了内核源码
find /usr/src -name "*rseq*" -type f
```

## 为什么其他系统调用能查到？

- `mmap`, `futex`, `clone` 等都是**经典系统调用**，存在了很多年
- 它们的文档在所有版本的 man-pages 包中都有包含
- `rseq` 作为新特性，文档更新滞后于内核实现

## rseq 简介

由于无法通过 man 查看，简单介绍一下：

- **Restartable Sequences**：可重启序列
- **用途**：用户态下实现高效的per-CPU操作
- **场景**：无锁数据结构、高性能计算等
- **机制**：如果线程在执行关键序列时被调度到其他CPU，内核会自动重启该序列

这是现代 glibc 用来优化某些操作的重要机制。